# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/podverse/01_audio.utils.ipynb.

# %% auto 0
__all__ = ['int16_max', 'normalize_volume', 'preprocess_wav', 'compute_embedding']

# %% ../notebooks/podverse/01_audio.utils.ipynb 2
import librosa
from resemblyzer.hparams import audio_norm_target_dBFS
import numpy as np
from pathlib import Path
int16_max = (2 ** 15) - 1

#!
#! Depreciated
#!
def normalize_volume(wav, target_dBFS, increase_only=False, decrease_only=False):
    if increase_only and decrease_only:
        raise ValueError("Both increase only and decrease only are set")
    rms         = np.sqrt(np.mean((wav * int16_max) ** 2))
    wave_dBFS   = 20 * np.log10(rms / int16_max)
    dBFS_change = target_dBFS - wave_dBFS
    if dBFS_change < 0 and increase_only or dBFS_change > 0 and decrease_only:
        return wav
    
    return wav * (10 ** (dBFS_change / 20))

#!
#! Depreciated
#!
def preprocess_wav(fpath_or_wav: Path):
    # Load the wav from disk if needed
    wav, source_sr = librosa.load(str(fpath_or_wav), sr=None)
        
    # Apply the preprocessing: normalize volume and shorten long silences 
    wav = normalize_volume(wav, audio_norm_target_dBFS, increase_only=True)
    
    return wav, source_sr

# %% ../notebooks/podverse/01_audio.utils.ipynb 3
from resemblyzer import VoiceEncoder

def compute_embedding(wav, rate=1.3):
    """
    Cuts up wav in chunks of width 25600 = 1.6*16_000
    """
    enc = VoiceEncoder("cpu")
    #      
    # rate: how many partial utterances should occur per second
    # len(X) ~ len(wav)/(16_000/rate)
    _, X, S = enc.embed_utterance(wav[:], return_partials=True, rate=rate) 
    return X,S

